/*
 * stm32f407xx_i2c_driver.c
 *
 *  Created on: 02-Oct-2021
 *      Author: 007ma
 */


#include <stm32f407xx_i2c_driver.h>




void I2C_PericlockEnable(I2C_RegDef_t *pI2Cx,uint8_t ENorDI)
{
	if(ENorDI == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}
	else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}

	}
}



void I2C_CloseReceiveData(I2C_Handle_t *pI2CHandle)
{
	// clearing interuptt wic is enabled
	pI2CHandle->pI2Cx->CR2 &= ~(1<<10);
	pI2CHandle->pI2Cx->CR2 &= ~(1<<9);

	pI2CHandle->TxRxState = I2C_READY;
	pI2CHandle->pRxBuffer = NULL;
	pI2CHandle->RxLengt = 0;
	pI2CHandle->RxSize = 0;
	if(pI2CHandle->I2C_PinConfig.I2C_ACKControl == I2C_ACK_EN)
	{
	I2C_ManageAcking(pI2CHandle->pI2Cx, ENABLE);
	}
}
void I2C_Close_SendData(I2C_Handle_t *pI2CHandle)
{

	// clearing interuptt wic is enabled
	pI2CHandle->pI2Cx->CR2 &= ~(1<<10);
	pI2CHandle->pI2Cx->CR2 &= ~(1<<9);

	pI2CHandle->TxRxState = I2C_READY;
	pI2CHandle->pTxBuffer = NULL;
	pI2CHandle->TxLengt = 0;

}
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
	I2C_PericlockEnable(pI2CHandle->pI2Cx, ENABLE);
	uint32_t tempreg=0;

	// it is to enable or disable i2c ack default ack is disabled
	tempreg |= pI2CHandle->I2C_PinConfig.I2C_ACKControl <<10;
	pI2CHandle->pI2Cx->CR1 = tempreg;
	// intiliazing freq of our board wic is to be written in cr2 register
	tempreg = 0;
	tempreg |= RCC_GetPCLK1Value()/1000000U ;
	pI2CHandle->pI2Cx->CR2 = tempreg & 0x3f;
	//configaration of slave address stored in oar register
	tempreg = 0;
	tempreg |= pI2CHandle->I2C_PinConfig.I2C_DeviceAddress <<1;
	tempreg |= (1<<14); //always be kept 1 by software
	pI2CHandle->pI2Cx->OAR1 = tempreg;
	//Configuration of ccr register
	uint16_t ccr_value = 0;
	tempreg =0;
	if(pI2CHandle->I2C_PinConfig.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
	{
		// IT IS STANDARD MODE
		ccr_value = RCC_GetPCLK1Value()/(2*pI2CHandle->I2C_PinConfig.I2C_SCLSpeed);
		//pclk is periperal clock and sclk is clock generated by i2c
		tempreg = (ccr_value & 0xfff);
	}
	else
	{

		tempreg |= (1<<15);
		tempreg |= (pI2CHandle->I2C_PinConfig.I2C_FMDutyCycle << 14);
		if(pI2CHandle->I2C_PinConfig.I2C_FMDutyCycle == I2C_FM_DUTY_2)
		{
		ccr_value = RCC_GetPCLK1Value()/(3*pI2CHandle->I2C_PinConfig.I2C_SCLSpeed);
		}else{
			ccr_value = RCC_GetPCLK1Value()/(25*pI2CHandle->I2C_PinConfig.I2C_SCLSpeed);

			 }
		tempreg |= (ccr_value & 0xfff);
		// configure for fast mode
	}
	pI2CHandle->pI2Cx->CCR |= tempreg;
	// assigining value to trise register
	if(pI2CHandle->I2C_PinConfig.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
		{
			// mode is standard mode
			tempreg = (RCC_GetPCLK1Value()/1000000U)+1;

		}
		else
		{
			// mode is fastmode
			tempreg = ((RCC_GetPCLK1Value()*300)/100000000U)+1;
		}

		pI2CHandle->pI2Cx->TRISE = (tempreg & 0x3f);
}

void I2C_DeInit(I2C_RegDef_t *pI2Cx)
{
	if(pI2Cx == I2C1)
		{
			I2C1_REG_RESET();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_REG_RESET();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_REG_RESET();
		}

}
static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= (1<<8);
}

uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx,uint32_t FlagName)
{
	if(pI2Cx->SR1 &FlagName)
		{
			return FLAG_SET;
		}
		return FLAG_RESET;
}

static void I2C_Execute_Addresswrite(I2C_RegDef_t *pI2Cx,uint8_t Slaveaddress)
{
	Slaveaddress = Slaveaddress << 1;
	Slaveaddress &= ~(1);
	pI2Cx->DR = Slaveaddress;
}

static void I2C_ClearADDR_Flag(I2C_Handle_t *pI2CHandle)
{
	uint32_t dummyread;
	// ceck for master or in slave mode
	if(pI2CHandle->pI2Cx->SR2 & (1<<0))
	{
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
		{
			if(pI2CHandle->RxSize == 1)
			{
				I2C_ManageAcking(pI2CHandle->pI2Cx, DISABLE);
				// clearing addr flag
				dummyread = pI2CHandle->pI2Cx->SR1;
				dummyread = pI2CHandle->pI2Cx->SR2;
				(void)dummyread;
			}
		}else
		{
			dummyread = pI2CHandle->pI2Cx->SR1;
			dummyread = pI2CHandle->pI2Cx->SR2;
			(void)dummyread;

		}

	}else
	{
		dummyread = pI2CHandle->pI2Cx->SR1;
		dummyread = pI2CHandle->pI2Cx->SR2;
		(void)dummyread;
	}

}

 void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= (1<<9);

}

 void I2C_SlaveEnableDisableCallbackEve(I2C_RegDef_t *pI2Cx,uint8_t ENorDI)
 {
	 if(ENorDI == ENABLE)
	 {
		 pI2Cx->CR2 |= (1<<10);
		 pI2Cx->CR2 |= (1<<9);
		 pI2Cx->CR2 |= (1<<8);
	 }
	 else
	 {
		 pI2Cx->CR2 &= ~(1<<10);
		 pI2Cx->CR2 &= ~(1<<9);
		 pI2Cx->CR2 &= ~(1<<8);
	 }
 }
void I2C_MasterSend_Data(I2C_Handle_t *pI2CHandle,uint8_t *pTxbuffer,uint8_t Len,uint8_t Slaveaddress,uint8_t Sr)
{
	// generate start function
	I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
	// ceck start generation is completed by ceking sb flag in sr1
	// wait until sb bit is set
	while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SB_FLAG));
	//SEND TE ADDRESS OF SLAVE USING DATA REGISTER WIT R/W TO 0
	I2C_Execute_Addresswrite(pI2CHandle->pI2Cx,Slaveaddress);
	//ceck addr flag to know weater address is sent succesfully or not and clear it
	while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_ADDR_FLAG));
	//clearing
	I2C_ClearADDR_Flag(pI2CHandle);
	// confirm weter transmission buffer is empty or not before sending data
	// send data until len is 0
	while(Len>0)
	{
		while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_TXE_FLAG));
		pI2CHandle->pI2Cx->DR = *pTxbuffer;
		pTxbuffer ++;
		Len -- ;
	}
	//after sending data wait for txe =1 and btf = 1 before closing comminication
	while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_TXE_FLAG));
	while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_BTF_FLAG));
	//generating stop condition
	if(Sr == I2C_NO_SR)
	{
		I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
	}
}

static void I2C_Execute_Addressread(I2C_RegDef_t *pI2Cx,uint8_t Slaveaddress)
{
	Slaveaddress = Slaveaddress << 1;
	Slaveaddress |= 0x1;
	pI2Cx->DR = Slaveaddress;
}

void I2C_ManageAcking(I2C_RegDef_t *pI2Cx,uint8_t ENorDI)
{
	if(ENorDI == ENABLE)
	{
		pI2Cx->CR1 |= (1<<10);
	}
	else
	{
		pI2Cx->CR1 &= ~(1<<10);
	}
}
void I2C_MasterReceiveData(I2C_Handle_t *pI2CHandle,uint8_t *pRxbuffer,uint8_t Len,uint8_t Slaveaddress,uint8_t Sr)
{
	I2C_GenerateStartCondition(pI2CHandle->pI2Cx); // Enabling periperal by using control register
	while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SB_FLAG)); // wait for sb bit to set
	I2C_Execute_Addressread(pI2CHandle->pI2Cx,Slaveaddress); // address read and write bit to be canged
	while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_ADDR_FLAG));
	if(Len == 1)
	{
		I2C_ManageAcking(pI2CHandle->pI2Cx,DISABLE);
		I2C_ClearADDR_Flag(pI2CHandle);
		while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_RXE_FLAG));
		if(Sr == 0)
			{
				I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
			}

		*pRxbuffer =pI2CHandle->pI2Cx->DR;

	}
	if(Len>1)
	{
		I2C_ClearADDR_Flag(pI2CHandle);
		for(uint32_t i=Len;i>=0;i--)
		{
			while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_RXE_FLAG));

			if(i==2)
			{
				I2C_ManageAcking(pI2CHandle->pI2Cx,DISABLE);
				if(Sr == I2C_NO_SR)
					{
						I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
					}
			}
			*pRxbuffer =pI2CHandle->pI2Cx->DR;
			pRxbuffer++;
		}

	}
	if(pI2CHandle->I2C_PinConfig.I2C_ACKControl == I2C_ACK_EN)
	{
	I2C_ManageAcking(pI2CHandle->pI2Cx,ENABLE);
	}
}

uint8_t I2C_MasterSend_DataIT(I2C_Handle_t *pI2CHandle,uint8_t *pTxbuffer,uint8_t Len,uint8_t Slaveaddress,uint8_t Sr)
{
	uint8_t busystate = pI2CHandle->TxRxState;
	if((busystate != I2C_BUSY_IN_TX) && (busystate != I2C_BUSY_IN_RX))
	{
		pI2CHandle->pTxBuffer = pTxbuffer;
		pI2CHandle->TxLengt = Len;
		pI2CHandle->TxRxState = I2C_BUSY_IN_TX;
		pI2CHandle->Deviceaddr = Slaveaddress;
		pI2CHandle->Sr = Sr;


		I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

		// enabling interupt for txe

		pI2CHandle->pI2Cx->CR2 |= (1<<10);
		pI2CHandle->pI2Cx->CR2 |= (1<<9);
		pI2CHandle->pI2Cx->CR2 |= (1<<8);


	}
	return busystate;

}
uint8_t I2C_MasterReceiveDataIT(I2C_Handle_t *pI2CHandle,uint8_t *pRxbuffer,uint8_t Len,uint8_t Slaveaddress,uint8_t Sr)
{
	uint8_t busystate = pI2CHandle->TxRxState;
		if((busystate != I2C_BUSY_IN_TX) && (busystate != I2C_BUSY_IN_RX))
		{
			pI2CHandle->pRxBuffer = pRxbuffer;
			pI2CHandle->RxLengt = Len;
			pI2CHandle->TxRxState = I2C_BUSY_IN_RX;
			pI2CHandle->Deviceaddr = Slaveaddress;
			pI2CHandle->Sr = Sr;



			I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

			// enabling interupt for txe

			pI2CHandle->pI2Cx->CR2 |= (1<<10);
			pI2CHandle->pI2Cx->CR2 |= (1<<9);
			pI2CHandle->pI2Cx->CR2 |= (1<<8);


		}
		return busystate;
}

void I2C_IRQ_Interuppt_Config(uint8_t IRQNumber, uint8_t EnorDI)
{
if(EnorDI == ENABLE)
{
	if(IRQNumber <= 31)
	{
		//program ISERX register refer user manul of arm cortex M4 processor side registers
		*NVIC_ISER0 |= (1<<IRQNumber);
	}else if(IRQNumber >31 && IRQNumber <64)
	{
		//program ISER1 register refer user manul of arm cortex M4
		*NVIC_ISER1 |= ((1<<IRQNumber)%32);
	}else if(IRQNumber >=64 && IRQNumber <96)
	{
		//program ISER2 register refer user manul of arm cortex M4
		*NVIC_ISER2 |= ((1<<IRQNumber)%64);
	}

}else{
	//it is used to program ICERX register it is used to clear the interrupt
	if(IRQNumber <= 31)
			{
			*NVIC_ICER0 |= (1<<IRQNumber);

			}else if(IRQNumber >31 && IRQNumber <64)
			{
				*NVIC_ICER1 |= ((1<<IRQNumber)%32);

			}else if(IRQNumber >=64 && IRQNumber <96)
			{
				*NVIC_ICER2 |= ((1<<IRQNumber)%64);

			}

}
}

void I2C_IRQ_Interuppt_priority_config(uint8_t IRQNumber,uint32_t IRQPriority)
{
	uint8_t iprx = IRQNumber/4; //calculated to know wic IRQ register total tere are 60 registers
	uint8_t section = IRQNumber %4; //tere are four IRQ register section in one register
	uint8_t shift_value = (8*section) + (8-NO_OF_PR_BIT_IMPLIMENTED);
	*(NVIC_PR_BASE_ADDR + iprx) |= (IRQPriority <<(shift_value));
}

void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx,uint8_t ENorDI)
{
	if(ENorDI == ENABLE)
	{
		pI2Cx->CR1 |= (1<<0);
	}
	else
	{
		pI2Cx->CR1 &= ~(1<<0);
	}
}

void I2C_EV_IRQHandling(I2C_Handle_t *pI2CHandle)
{
	// intruppt enabling registers
	uint8_t temp1 = pI2CHandle->pI2Cx->CR2 & (1<<9);  // for event related interuppts
	uint8_t temp2 = pI2CHandle->pI2Cx->CR2 & (1<<10); // for buffer related interuppts
	// status registers
	uint8_t temp3 = pI2CHandle->pI2Cx->SR1 & (1<<0);

	if(temp1 && temp3)
	{
		//SB flag is set
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			I2C_Execute_Addresswrite(pI2CHandle->pI2Cx, pI2CHandle->Deviceaddr);
		}
		else if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
		{
			I2C_Execute_Addressread(pI2CHandle->pI2Cx, pI2CHandle->Deviceaddr);
		}

	}
	temp3 = pI2CHandle->pI2Cx->SR1 & (1<<1);
	if(temp1 && temp3)
	{
		// ADDR flag is set
		I2C_ClearADDR_Flag(pI2CHandle);

	}
	temp3 = pI2CHandle->pI2Cx->SR1 & (1<<2);
	if(temp1 && temp3)
	{
		// BTF Flag is set
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			//MAKE SURE TAT TXE IS ALSO SET
			if(pI2CHandle->pI2Cx->SR1 & (1<<7))
			{
				if(pI2CHandle->TxLengt == 0)
				{
				// btf and txe are bot are set
				// generating stop condition
				if(pI2CHandle->Sr != I2C_SR)
				{
				I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
				}
				// clearing all elements of structure wic contains data of tx and rx
				I2C_Close_SendData(pI2CHandle);
				// notify application about te event
				I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_TX_COMPLETE);
				}
			}
		}
	}

	temp3 = pI2CHandle->pI2Cx->SR1 & (1<<4);
	if(temp1 && temp3)
	{
		// Stop Flag is set
		// Stop flag only set in slave mode can be cleared by reading sr1 and writing cr1
		//reading of sr1 is already done in temp 3
		pI2CHandle->pI2Cx->CR1 |= 0x0000;
		// notify application
		I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_STOP);


	}
	temp3 = pI2CHandle->pI2Cx->SR1 & (1<<7);
	if(temp1 && temp2 && temp3 )
	{
		// if master mode
		if(pI2CHandle->pI2Cx->SR2 & (1<<0))
		{
		// TXE Flag is set
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			if(pI2CHandle->TxLengt > 0)
			{
				// load data in dr
				pI2CHandle->pI2Cx->DR = *(pI2CHandle->pTxBuffer);
				// decrement tx len
				pI2CHandle->TxLengt--;
				// increment ptxbuffer
				pI2CHandle->pTxBuffer++;
			}

		}
		}
		else
		{
			//it is in slave
			// to know if slave is in transmitter mode or receiver mode cek sr2 tra bit
			if(pI2CHandle->pI2Cx->SR2 & (1<<2))
			{
				//transmitter mode
				I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_DATA_REQ);
			}


		}
	}
	temp3 = pI2CHandle->pI2Cx->SR1 & (1<<6);
	if(temp1 && temp2 && temp3)
	{
		// ceck for master or in slave mode
		if(pI2CHandle->pI2Cx->SR2 & (1<<0))
		{
		// RXNE Flag is set
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
		{
			if(pI2CHandle->RxSize == 1)
			{
				//I2C_ManageAcking(pI2CHandle, ENABLE);
				*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;
				pI2CHandle->RxLengt--;


			}
			if(pI2CHandle->RxSize > 1)
			{
				if(pI2CHandle->RxLengt == 2)
				{
					I2C_ManageAcking(pI2CHandle->pI2Cx,DISABLE);
				}
				*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;
				pI2CHandle->pRxBuffer++;
				pI2CHandle->RxLengt--;

			}
			if(pI2CHandle->RxLengt == 0)
			{
				// generate stop conditon
				if(pI2CHandle->Sr == I2C_NO_SR)
				{
					I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
				}

				I2C_CloseReceiveData(pI2CHandle);

				//notify te application
				I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_RX_COMPLETE);
			}
		}
	}
		else
		{
			//slave mode
			//ceking for transmitter or receiver mode in sr2 reg tra bit
			if(!(pI2CHandle->pI2Cx->SR2 & (1<<2)))
			{
				//receive mode
				I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_DATA_RECEIVE);
			}


		}



}
}
void I2C_ERR_IRQHandling(I2C_Handle_t *pI2CHandle)
{
	uint8_t temp1 = pI2CHandle->pI2Cx->CR2 & (1<<8);

	uint8_t temp2 = pI2CHandle->pI2Cx->SR1 & (1<<8);
	if(temp1 && temp2)
	{
		// BERR ERROR STATUS
		// CLEARRING BUS ERROR FLAG
		pI2CHandle->pI2Cx->SR1 &= ~(1<<8);
		// notify te application
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERR_BERR);
	}

	temp2 = pI2CHandle->pI2Cx->SR1 & (1<<9);
	if(temp1 && temp2)
	{
		// ARBITRATION ERROR STATUS
		// CLEARRING BUS ERROR FLAG
		pI2CHandle->pI2Cx->SR1 &= ~(1<<9);
		// notify te application
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERR_ARLO);
	}

	temp2 = pI2CHandle->pI2Cx->SR1 & (1<<10);
	if(temp1 && temp2)
	{
		// AF ERROR STATUS
		// CLEARRING BUS ERROR FLAG
		pI2CHandle->pI2Cx->SR1 &= ~(1<<10);
		// notify te application
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERR_AF);
	}

	temp2 = pI2CHandle->pI2Cx->SR1 & (1<<11);
	if(temp1 && temp2)
	{
		// OVERRUN ERROR STATUS
		// CLEARRING BUS ERROR FLAG
		pI2CHandle->pI2Cx->SR1 &= ~(1<<11);
		// notify te application
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERR_OVRRN);
	}



	temp2 = pI2CHandle->pI2Cx->SR1 & (1<<14);
	if(temp1 && temp2)
	{
		// TIMEOUT ERROR STATUS
		// CLEARRING BUS ERROR FLAG
		pI2CHandle->pI2Cx->SR1 &= ~(1<<14);
		// notify te application
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERR_TIMEOUT);
	}

}



